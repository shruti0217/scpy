#!usr/bin/python3.8.0

"""
	Testing module to run unit tests against dashed_refactored module.
"""


from unittest import TestCase  			# used to define test cases (for ex: testing dashed function)
from unittest import main      			# main method from unittest, triggers user defined test cases
from dashed_refactored import dashed    # importing module to be tested


# creating first set of test cases, TestCase is a single unit of testing
# unitests must be defined in a class that is inheriting from "unittest.TestCase"
# within this class we can define any number of test cases
class TestDashedRefactored(TestCase):  

	@classmethod
	def setUpClass(cls):
		"""
			This method is used to load or set attribute that're applicable to whole class
			and could be used through the execution of test cases.
			It will be executed first and only once, before any test case is executed.
			Method is not mandatory but kept here just so we know how to load attributes one time only.
			Naming convention is import, must be named like this always.
			for example:
			------------
				-	enviroment = "production" or "qa"
				-	reading input data from a large file that is needed for unit testing.

			usage:
			------
				-	set values like: cls.enviroment = "testing" and use it like self.enviroment in other methods
		"""
		cls.enviroment = 'testing'

	@classmethod
	def tearDownClass(cls):
		"""
			Similar to setUpClass, used to reset or delete attributes from class
			just before class termination.
			Executed last and only once.
			Not mandatory to define, but just to show how to exit unit tests gracefully.
		"""
		pass

	def test_data_acceptance(self):
		"""
			This methods will contain actual test cases, method name must start with "test" keyword.
			unittests library will detect test cases by looking of "test" keyword.
			We're allowed to create any number of such methods to test different scenarios.
			In this method, we'll only test wether the dashed function accepts
			valid data or not.
		"""
		# create hard-coded input
		input_1 = 123456789
		input_2 = ''

		# with input_1 we expect an AssertionError, because integer data-type is not acceptable.
		self.assertRaises(AssertionError, dashed, input_1)

		# with input_2 we expect an AssertionError, because empty string is not acceptable.
		self.assertRaises(AssertionError, dashed, input_2)

	def test_final_output(self):
		"""
			Now here we test the output generated by dashed function.
		"""
		# create hard-coded input
		input_1 = 'dummy test string'
		input_2 = '123456789'

		# created expected output
		expected_output_1 = 'd-u-mmy t-e-st str-i-ng'
		expected_output_2 = '123456789'

		# perform tests
		actual_output_1 = dashed(input_1)
		# now we compare the actual output & expected output
		# we expect both of them to be identical, hence we use assertEqual
		self.assertEqual(actual_output_1, expected_output_1)

		# another way to perform the same comparison
		actual_output_2 = dashed(input_2)
		self.assertTrue(actual_output_2 == expected_output_2)

		

# entry point for the module
if __name__ == '__main__':
	# main method imported from unittest
	main()


"""
	Notes:
	------
	-	If all tests pass, we will get results OK and unittest will tell us how many tests ran.
	-	If a test fails, unittest will throw an exception and inform us which test failed & why.
	-	We could write tests to check if our code fails gracefully or not.
	-	But, if a positive case fails then it indicates that maybe the actual code needs some enhancements.
	-	If you can not unit test a pice of code, then it's good indication that your components are
		tightly coupled and code may need some refactoring.
	-	It's almost always better to have smaller movable pieces, rather than one complex structure.
	-	Write tests to fail your code for a given scenario, before actually investing time in your code
		to handle that scenario.

	Using this module:
	------------------
		-	Simple Usage:
			-------------
			-	python tester.py
				->	To execute all tests defined inside tester module
		
		-	unittest CLI:
			-------------
			-	python -m unittest
				->	'-m' stands for module, we're telling python to execute unittest module
				->	This will automatically try to detect unittest module in the current directory.

			-	python -m unittest tester
				->	Now we're explicitly telling unittest to execute tester module only.

			-	python -m unittest tester.TestDashedRefactored
				->	To execute only the test cases within the given class (TestDashedRefactored)

			-	python -m unittest tester.TestDashedRefactored.test_final_output
				->	To execute only a specific test case from a chosen class (TestDashedRefactored)
"""
